source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial
#X <- t(solucao_inicial("distancia.csv", grau))
X <- sol_inicial("distancia.csv")
#colnames(X) <- c("destino", "custo")
#X <- data.frame(X)
sum(X$custo)
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.5
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
#Limpando o ambiente
rm(list=ls())
###SELECIONA O GRAU DE VARIABILIDADE DA SOLUÇÃO INICIAL#####
###Valores pequenos significa uma solução inicial mais próxima###
###Da global, ou seja, mais gulosa.#####
grau <- 1
#Importando Bibliotecas e Arquivos necessários
library('matrixcalc')
#source('solucao_inicial.R')
source('solucao_inicial_2.R')
source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial
#X <- t(solucao_inicial("distancia.csv", grau))
X <- sol_inicial("distancia.csv")
#colnames(X) <- c("destino", "custo")
#X <- data.frame(X)
sum(X$custo)
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.5
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
#Limpando o ambiente
rm(list=ls())
###SELECIONA O GRAU DE VARIABILIDADE DA SOLUÇÃO INICIAL#####
###Valores pequenos significa uma solução inicial mais próxima###
###Da global, ou seja, mais gulosa.#####
grau <- 1
#Importando Bibliotecas e Arquivos necessários
library('matrixcalc')
#source('solucao_inicial.R')
source('solucao_inicial_2.R')
source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial
#X <- t(solucao_inicial("distancia.csv", grau))
X <- sol_inicial("distancia.csv")
#colnames(X) <- c("destino", "custo")
#X <- data.frame(X)
sum(X$custo)
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.2
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
#Limpando o ambiente
rm(list=ls())
###SELECIONA O GRAU DE VARIABILIDADE DA SOLUÇÃO INICIAL#####
###Valores pequenos significa uma solução inicial mais próxima###
###Da global, ou seja, mais gulosa.#####
grau <- 1
#Importando Bibliotecas e Arquivos necessários
library('matrixcalc')
#source('solucao_inicial.R')
source('solucao_inicial_2.R')
source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial
#X <- t(solucao_inicial("distancia.csv", grau))
X <- sol_inicial("distancia.csv")
#colnames(X) <- c("destino", "custo")
#X <- data.frame(X)
sum(X$custo)
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.2
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
#Limpando o ambiente
rm(list=ls())
###SELECIONA O GRAU DE VARIABILIDADE DA SOLUÇÃO INICIAL#####
###Valores pequenos significa uma solução inicial mais próxima###
###Da global, ou seja, mais gulosa.#####
grau <- 1
#Importando Bibliotecas e Arquivos necessários
library('matrixcalc')
#source('solucao_inicial.R')
source('solucao_inicial_2.R')
source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial com variacao (comente se quiser gulosa)
X <- t(solucao_inicial("distancia.csv", grau))
colnames(X) <- c("destino", "custo")
X <- data.frame(X)
#solucao inicial gulosa (comente se quiser uma solucao com algum tipo de aleatoriedade)
#X <- sol_inicial("distancia.csv")
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.5
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
#Limpando o ambiente
rm(list=ls())
###SELECIONA O GRAU DE VARIABILIDADE DA SOLUÇÃO INICIAL#####
###Valores pequenos significa uma solução inicial mais próxima###
###Da global, ou seja, mais gulosa.#####
grau <- 1
#Importando Bibliotecas e Arquivos necessários
library('matrixcalc')
#source('solucao_inicial.R')
source('solucao_inicial_2.R')
source('sol_inicial_gulosa.R')
source('vizinhanca.R')
#Lendo os dados
dados_custo <- as.matrix(read.csv(file="distancia.csv", header=FALSE, sep=","))
#Solução inicial com variacao (comente se quiser gulosa)
X <- t(solucao_inicial("distancia.csv", grau))
colnames(X) <- c("destino", "custo")
X <- data.frame(X)
#solucao inicial gulosa (comente se quiser uma solucao com algum tipo de aleatoriedade)
#X <- sol_inicial("distancia.csv")
#Escolhe 100 vizinhos próximos e calcula a temperatura inicial
tau <- 0.5
x1 <- X
deltaE <- NULL
for (i in 1:100){
deltaE <- c(deltaE,((sum(Vizinhanca(x1, dados_custo, 1)$custo)) - (sum(X$custo))))
}
T0 <- -mean(deltaE)/(log(tau))
#Constantes do SA
seqi <- seq(0.00001,1,0.00001)
costt <- sum(X$custo)
iteracao <- 0
nivel <- 1 #nível inicial
D0 <- 0.9 #variação da temperatura inicial
Tk <- T0
deltaE <- 0
m <- 1
xbest <- X
#Loop do SA
while (iteracao < 10000 && Tk > 0.001*T0 && nivel<=7){
aceitacao <- 0
m <- 0
menordeltaE <- Inf
todosdeltaE <- NULL
while (m <= 200 && aceitacao<=12){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
while (deltaE == 0){
cost1 <- sum(X$custo)
x1 <- Vizinhanca(X, dados_custo, nivel)
cost2 <- sum(x1$custo)
deltaE <- cost2 - cost1
}
if (deltaE <= 0){
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
aceitacao <- aceitacao +1
X <- x1
if (sum(x1$custo) < sum(xbest$custo)) xbest <- x1
costt <- c(costt,cost2)
} else {
prob <- exp(-deltaE/Tk)
if (sample(seqi,1)<prob) {
if (deltaE < menordeltaE) menordeltaE <- deltaE
todosdeltaE <- c(todosdeltaE,deltaE)
X <- x1
costt <- c(costt,cost2)
aceitacao <- aceitacao +1
}
}
m <- m+1
}
Tk <- min(abs(menordeltaE)/abs(mean(todosdeltaE)), D0)*Tk
if (m >= 200) {
nivel <- nivel+1
}
if (aceitacao > 1){
nivel <- 1
}
iteracao <- iteracao+1
}
custofinal <- sum(xbest$custo)
#plota custos e imprime o custo final
plot(costt, type="line")
cat("Melhor custo: ", custofinal,"\n")
